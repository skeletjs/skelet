const { expect } = require('chai')

const final = require('skelet-utils/lib/final')

describe('skelet-utils / final', () => {
  it('should throw when instance is invalid', () => {
    expect(() => final()).to.throw(/instance must be an instance of object/)
    expect(() => final(null)).to.throw(/instance must be an instance of object/)
    expect(() => final(1)).to.throw(/instance must be an instance of object/)
    expect(() => final('123')).to.throw(/instance must be an instance of object/)
  })

  it('should throw when fn is not a function', async () => {
    expect(() => final({}, null)).to.throw(/fn must be a function/)
    expect(() => final({}, {})).to.throw(/fn must be a function/)
    expect(() => final({}, [])).to.throw(/fn must be a function/)
    expect(() => final({}, 123)).to.throw(/fn must be a function/)
    expect(() => final({}, 'str')).to.throw(/fn must be a function/)
  })

  it('should throw when trying to override  class', async () => {
    class A {
      constructor () {
        final(this, function x () { return 'x' })
      }
    }

    class B extends A {
      x () { return 'y' }
    }

    expect(() => new B()).to.throw(/You are not allowed to override A.x/)
  })

  it('should throw when trying to reassign method', async () => {
    class A {
      constructor () {
        final(this, function x () { return 'x' })
      }
    }

    const a = new A()

    expect(() => (a.x = 'y')).to.throw(/You are not allowed to reassign A.x/)
  })

  it('should throw when trying to reassign method via defineProperty on the instance', async () => {
    class A {
      constructor () {
        final(this, function x () { return 'x' })
      }
    }

    const a = new A()

    expect(() => Object.defineProperty(a, 'x', { get: () => {} })).to.throw(/Cannot redefine property: x/)
  })

  it('should throw when trying to reassign method via defineProperty on the prototype', async () => {
    class A {
      constructor () {
        final(this, function x () { return 'x' })
      }
    }
    Object.defineProperty(A.prototype, 'x', { get: () => 'y' })

    expect(() => new A()).to.throw(/You are not allowed to override A.x/)
  })

  it('should not impact the `this` reference of the method itself', async () => {
    class A {
      constructor () {
        this.test = 'TEST'

        final(this, function x () { return this.test })
      }
    }

    const result = new A().x()

    expect(result).to.equal('TEST')
  })
})
